
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>uav_placement</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-01-08"><meta name="DC.source" content="uav_placement.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Creating a new environment</a></li><li><a href="#2">Functions Created: generate_data</a></li><li><a href="#3">Functions Created: optimal_points</a></li><li><a href="#4">Functions Created: optimal_points</a></li><li><a href="#5">Generating the data from each of the 2D Gaussian Distributions.</a></li><li><a href="#6">Plotting each of the Gaussian Dsitributions.</a></li><li><a href="#7">Getting the K-Means Centroids and Clusters</a></li><li><a href="#8">Generating Random Points for Placing the the Random UAVs</a></li><li><a href="#9">Plotting the K-Means Centroids</a></li><li><a href="#10">Getting the optimal UAV power, height, coverage area, and the users served per Cluster</a></li><li><a href="#11">Getting the optimal UAV locations for the UAV Relays</a></li><li><a href="#12">Plotting the Ranges of all the UAVs</a></li><li><a href="#13">Plotting the Population Density</a></li><li><a href="#14">Plotting the optimal UAV Placement Locations</a></li><li><a href="#15">Comparing the Utility of K-Means vs Random Placement by checking Total Channel Capacity and Number of Users served.</a></li><li><a href="#16">Using Graph Theory to get the Shortest Distance between Nodes</a></li><li><a href="#17">Plotting the Updated Ranges of all the UAVs</a></li><li><a href="#18">Plotting the updated optimal UAV Placement Locations</a></li><li><a href="#19">Calculating the Performance Metrics for the Dijkstra Algorithm</a></li></ul></div><h2 id="1">Creating a new environment</h2><pre class="codeinput">clc;
clear <span class="string">all</span>;
close <span class="string">all</span>;
</pre><h2 id="2">Functions Created: generate_data</h2><pre class="language-matlab">
<span class="comment">% Function that generates data from multiple two dimensional Gaussians.</span>

<span class="keyword">function</span> [data] = generate_data(num_of_clusters, start_range_mean, <span class="keyword">...</span><span class="comment"> </span>
    end_range_mean, start_range_var, end_range_var, data_points_per_cluster)

    <span class="comment">% num_of_clusters: Number of clusters that data should be generating for</span>
    <span class="comment">% start_range_mean: Starting of the range of the mean</span>
    <span class="comment">% end_range_mean: Ending of the range of the mean</span>
    <span class="comment">% start_range_var: Starting of the range of the var</span>
    <span class="comment">% end_range_var: Ending of the range of the var</span>
    <span class="comment">% data_points_per_cluster: Number of data points that are generated per</span>
    <span class="comment">% cluster</span>

    data = [];

    <span class="keyword">for</span> i=1:num_of_clusters
        
        <span class="comment">% Generating the mean per cluster</span>
        mu = start_range_mean + (end_range_mean - start_range_mean).* <span class="keyword">...</span>
            rand(2,1);

        <span class="comment">% Generating the variance per cluster</span>

        <span class="comment">% Creates a PSD Matrix</span>
        <span class="keyword">while</span> (true)
          <span class="comment">% Such a scaling is done (from -1 to 1 as the rand function </span>
          <span class="comment">% generates only from 0 to 1. Such a scaling is important as if </span>
          <span class="comment">% the matrix only produces values from 0 to 1, the sigma matrix</span>
          <span class="comment">% is always positively correlated. Hence the range from -1 to 1</span>
          <span class="comment">% ensures that we get both positive and negatively correalted 2D</span>
          <span class="comment">% Gaussian Distributions.</span>
          A = -1 + 2.*rand(2, 2);
          <span class="keyword">if</span> (rank(A) == 2);
              <span class="comment">% Ensures that the matrix is full rank.</span>
              <span class="keyword">break</span>; 
          <span class="keyword">end</span>    
        <span class="keyword">end</span>
        sigma = A' * A; <span class="comment">% Makes sure that sigma is PSD.</span>
        sigma = start_range_var + (end_range_var - start_range_var).*sigma;

        <span class="comment">% Generating the Data  </span>
        data_per_cluster = mvnrnd(mu, sigma, data_points_per_cluster);
        data = [data; data_per_cluster];
    <span class="keyword">end</span>

</pre><h2 id="3">Functions Created: optimal_points</h2><pre class="language-matlab">
<span class="comment">% Function that returns the points that the UAV should either stay or</span>
<span class="comment">% travel to and fro</span>

<span class="keyword">function</span> [points] = optimal_points(x_bs, y_bs, x_c, y_c, P_bs, P_uav, <span class="keyword">...</span>
    bw_bs, bw_uav, h_uav, h_bs, h_relay, capacity_thresh, var_n)

    <span class="comment">% x_bs: x coordinate of base station</span>
    <span class="comment">% y_bs: y coordinate of base station</span>
    <span class="comment">% x_c: x coordinate of centroid</span>
    <span class="comment">% y_c: y coordinate of centroid</span>
    <span class="comment">% P_bs: Power of the base station</span>
    <span class="comment">% P_uav: Power of the UAV</span>
    <span class="comment">% bw_bs: Bandwidth of the base station</span>
    <span class="comment">% bw_uav: Bandwidth of the UAV</span>
    <span class="comment">% h_uav: Height of the uav;</span>
    <span class="comment">% capacity_thresh: Threshold of the capacity required to transmit.</span>
    <span class="comment">% var_n: Noise Variance.</span>

    <span class="comment">% Converting from a 2D plane to a single line</span>
    d = abs(sqrt((x_c - x_bs)^2 + (y_c -  y_bs)^2));
    theta = atan2((y_c - y_bs), (x_c - x_bs));

    <span class="comment">% Defining the equations</span>
    syms <span class="string">x</span>
    capacity_bs = bw_bs*log(1 + P_bs/((x^2 + (h_relay-h_bs)^2) * var_n));
    capacity_uav = bw_uav*log(1 + P_uav/(((x-d)^2 + (h_uav-h_relay)^2) * var_n));
    
    <span class="comment">% Solving the equations. vpasolve is a numerical solver.</span>
    intersection_bs_thresh = vpasolve(capacity_bs == capacity_thresh, x, <span class="keyword">...</span>
        [0, d]);
    intersection_uav_thresh = vpasolve(capacity_uav == capacity_thresh, x, <span class="keyword">...</span>
        [0, d]);
    intersection_both_capacities = vpasolve(capacity_uav == capacity_bs, x, <span class="keyword">...</span>
        [0, d]);
    val_intersection_both_capacities = subs(capacity_uav, intersection_both_capacities);
  
    <span class="keyword">if</span> (val_intersection_both_capacities &gt; capacity_thresh)
        <span class="comment">% if the intersection of both the capacities is more than the</span>
        <span class="comment">% threshold.</span>
        x1 = x_bs + cos(theta) * intersection_both_capacities;
        y1 = y_bs + sin(theta) * intersection_both_capacities;
        points = [x1, y1; x1, y1];
    <span class="keyword">elseif</span> (isempty(intersection_bs_thresh) || isempty(intersection_uav_thresh))
        <span class="comment">% If the intersection is less than the threshold and there is no</span>
        <span class="comment">% intersection between the threshold and the two curves. Basically</span>
        <span class="comment">% this means that the power is not enough for establishing the</span>
        <span class="comment">% optimal channel capacity.</span>
        points = [x_bs, y_bs; x_bs, y_bs];
    <span class="keyword">else</span>
        x1 = x_bs + cos(theta) * intersection_bs_thresh;
        y1 = y_bs + sin(theta) * intersection_bs_thresh;
        x2 = x_bs + cos(theta) * intersection_uav_thresh;
        y2 = y_bs + sin(theta) * intersection_uav_thresh;
        points = [x1, y1; x2, y2];
    <span class="keyword">end</span>

</pre><h2 id="4">Functions Created: optimal_points</h2><pre class="language-matlab">
<span class="comment">% Function that gives the optimal Power, Height, Coverage Radius, Users</span>
<span class="comment">% Served with the given thresholds. </span>

<span class="keyword">function</span> [pow, height, rad, users_served, total_users] = optimize_pow_height_cluster(k_means_cluster, <span class="keyword">...</span><span class="comment"> </span>
    centroid, p_thresh, h_thresh, alpha, channel_cap_thresh, bw_uav, var_n)
    
    <span class="comment">% Input:</span>
    <span class="comment">% k_means_cluster: Contains the x and y cooordinates of all points in</span>
    <span class="comment">% the cluster.</span>
    <span class="comment">% centroid: Contains the x and y coordinate of the centroid of the</span>
    <span class="comment">% cluster.</span>
    <span class="comment">% p_thresh: Power threshold of the UAV.</span>
    <span class="comment">% h_thresh: Minimum power threshold of the UAV.</span>
    <span class="comment">% alpha: Tradeoff between height and power.</span>
    <span class="comment">% channel_cap_thresh: Minimum channel capacity required for proper</span>
    <span class="comment">% communication.</span>
    <span class="comment">% bw_uav: Bandwidth of the UAV communication.</span>
    <span class="comment">% var_n: Noise Variance</span>
    
    <span class="comment">% Output:</span>
    <span class="comment">% pow: Power required by the UAV to communicate.</span>
    <span class="comment">% height: Minimum height required by the UAV to communicate.</span>
    <span class="comment">% rad: Radius of the cluster that can be served.</span>
    <span class="comment">% users_served: Number of users served.</span>
    
    <span class="comment">% Latex Equation:</span>
    <span class="comment">% \textrm{min }(\alpha P + (1 - \alpha) * H) \\</span>
    <span class="comment">% \textrm{subject to: } \\</span>
    <span class="comment">% 0 &lt;= P &lt;= P_{Threshold} \\</span>
    <span class="comment">% H &gt;= H_{Threshold} \\</span>
    <span class="comment">% BW*log (1 + \frac{P}{D^2 + H^2})</span>

    
    <span class="comment">% Defining the objective function</span>
    prob = optimproblem(<span class="string">'ObjectiveSense'</span>,<span class="string">'min'</span>);
    x = optimvar(<span class="string">'x'</span>,2,1);
    prob.Objective = alpha*x(1) + (1-alpha)*x(2);
    
    <span class="comment">% Defining the Constraints</span>
    cons1 = x(1) &lt;= p_thresh;
    cons2 = x(2) &gt;= h_thresh; 
    cons3 = x(1) &gt;= 0;
    
    <span class="comment">% Applying the constraints to the problem, leaving constraint 4. That</span>
    <span class="comment">% will be added in the for loop.</span>
    prob.Constraints.cons1 = cons1;
    prob.Constraints.cons2 = cons2;
    prob.Constraints.cons3 = cons3;
    
    
    <span class="comment">% Creating the Data Array,</span>
    dist = (k_means_cluster(:, 1) - centroid(1,1)) .^ 2 + <span class="keyword">...</span><span class="comment"> </span>
        (k_means_cluster(:, 2) - centroid(1,2)) .^ 2;
    
    <span class="comment">% Sorting the array</span>
    [~, id] = sort(dist(:,1));
    dist = dist(id, :);
    
    <span class="comment">% Creating a Loop to check which max</span>
    K = size(k_means_cluster, 1);
    
    pow = 0;
    height = 0;
    rad = 0;
    users_served = 0;
    total_users = K;
    
    <span class="keyword">for</span> i=K:-1:1
        cons4 = bw_uav * log(1+x(1)/((dist(i,1) + x(2)^2)*var_n))&gt;=channel_cap_thresh;
        prob.Constraints.cons4 = cons4;
        x0.x = [p_thresh, 2*h_thresh];
        sol = solve(prob, x0);
        <span class="comment">% Check whether the constrainsts are satisfied.</span>
        check = infeasibility(cons1, sol) || infeasibility(cons2, sol) || <span class="keyword">...</span>
            infeasibility(cons3, sol) || infeasibility(cons4, sol);
        <span class="keyword">if</span> (check==0)
            pow = sol.x(1,1);
            height = sol.x(2, 1);
            rad = sqrt(dist(i, 1));
            users_served = i;
            <span class="keyword">break</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span> 

</pre><h2 id="5">Generating the data from each of the 2D Gaussian Distributions.</h2><pre class="codeinput"><span class="comment">% Parameters that can be changed according to the experiments.</span>
num_of_clusters = 40;
start_range_mean = -40;
end_range_mean = 40;
start_range_var = 0;
end_range_var =  10;
data_points_per_cluster = 100;
no_of_users = num_of_clusters * data_points_per_cluster;

<span class="comment">% Calling the generate_data function.</span>
data = generate_data(num_of_clusters, start_range_mean, end_range_mean, <span class="keyword">...</span>
    start_range_var, end_range_var, data_points_per_cluster);

X = data(:, 1);
Y = data(: ,2);
</pre><h2 id="6">Plotting each of the Gaussian Dsitributions.</h2><pre class="codeinput">figure(<span class="string">'Name'</span>, <span class="string">'Gaussian Clusters'</span>, <span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>, <span class="keyword">...</span>
    [0 0 1 1]);
<span class="keyword">for</span> i=1:num_of_clusters
    plot(data((i-1)*100 + 1: (i)*100, 1), data((i-1)*100 + 1: (i)*100, 2), <span class="string">'.'</span>);
    hold <span class="string">on</span>;
<span class="keyword">end</span>

hold <span class="string">off</span>;
title(<span class="string">'Gaussian Distributions'</span>);
xlabel(<span class="string">'X Distance'</span>);
ylabel(<span class="string">'Y Distance'</span>);
</pre><img vspace="5" hspace="5" src="uav_placement_01.png" alt=""> <h2 id="7">Getting the K-Means Centroids and Clusters</h2><pre class="codeinput">num_of_centroids = 40;
[idx, centroids] = kmeans(data, num_of_centroids);

<span class="comment">% Getting the Clusters Associated with each centroid.</span>
k_means_clusters = cell(num_of_centroids, 1);
<span class="keyword">for</span> i = 1:num_of_centroids
    k_means_clusters{i} = [X(idx==i),Y(idx==i)] ;
<span class="keyword">end</span>
</pre><h2 id="8">Generating Random Points for Placing the the Random UAVs</h2><pre class="codeinput">start_range_random = start_range_mean - sqrt(end_range_var);
end_range_random = end_range_mean + sqrt(end_range_var);
X_random = start_range_random + (end_range_random - start_range_random) * <span class="keyword">...</span>
    rand(num_of_clusters, 1);
Y_random = start_range_random + (end_range_random - start_range_random) * <span class="keyword">...</span>
    rand(num_of_clusters, 1);
random_centroids = [X_random, Y_random];

figure(<span class="string">'Name'</span>, <span class="string">'Random Centroids'</span>, <span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>, <span class="keyword">...</span>
    [0 0 1 1]);

gscatter(X, Y, idx);
hold <span class="string">on</span>;
p_centroids_random = plot(random_centroids(:,1), random_centroids(:,2), <span class="keyword">...</span>
    <span class="string">'kx'</span>, <span class="string">'MarkerSize'</span>, 15, <span class="string">'LineWidth'</span>, 3, <span class="string">'DisplayName'</span>,<span class="string">'Random Centroids'</span>);
hold <span class="string">off</span>;

legend([p_centroids_random], <span class="string">'Random Centroids'</span>);
title(<span class="string">'Random Centroids'</span>);
xlabel(<span class="string">'X Distance'</span>);
ylabel(<span class="string">'Y Distance'</span>);
</pre><img vspace="5" hspace="5" src="uav_placement_02.png" alt=""> <img vspace="5" hspace="5" src="uav_placement_03.png" alt=""> <h2 id="9">Plotting the K-Means Centroids</h2><pre class="codeinput">figure(<span class="string">'Name'</span>, <span class="string">'K Means Centroids'</span>, <span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>, <span class="keyword">...</span>
    [0 0 1 1]);

gscatter(X, Y, idx);
hold <span class="string">on</span>;
p_centroids = plot(centroids(:,1), centroids(:,2), <span class="string">'kx'</span>, <span class="string">'MarkerSize'</span>, <span class="keyword">...</span>
    15, <span class="string">'LineWidth'</span>, 3, <span class="string">'DisplayName'</span>,<span class="string">'Centroids'</span>);
hold <span class="string">off</span>;

legend([p_centroids], <span class="string">'Centroids'</span>);
title(<span class="string">'K Means Centroids'</span>);
xlabel(<span class="string">'X Distance'</span>);
ylabel(<span class="string">'Y Distance'</span>);
</pre><img vspace="5" hspace="5" src="uav_placement_04.png" alt=""> <h2 id="10">Getting the optimal UAV power, height, coverage area, and the users served per Cluster</h2><pre class="codeinput"><span class="comment">% The five columns are optimal power, optimal height, radius of the users</span>
<span class="comment">% served, number of users served</span>
optimal_data = zeros(num_of_centroids, 5);
power_threshold = 10;
height_threshold = 0.5;
bw_uav  = 5;
alpha = 0.5;
chan_capacity_thresh = 1;
var_n = 0.5;

<span class="keyword">for</span> i=1:num_of_centroids
    [optimal_data(i,1), optimal_data(i,2), optimal_data(i,3), <span class="keyword">...</span>
        optimal_data(i,4), optimal_data(i,5)] = <span class="keyword">...</span>
        optimize_pow_height_cluster(k_means_clusters{i}, centroids(i,:), <span class="keyword">...</span>
        power_threshold, height_threshold, alpha, chan_capacity_thresh, bw_uav, <span class="keyword">...</span>
        var_n);
<span class="keyword">end</span>
</pre><pre class="codeoutput">
Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Converged to an infeasible point.

fmincon stopped because the size of the current step is less than
the value of the step size tolerance but constraints are not
satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Converged to an infeasible point.

fmincon stopped because the size of the current step is less than
the value of the step size tolerance but constraints are not
satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Converged to an infeasible point.

fmincon stopped because the size of the current step is less than
the value of the step size tolerance but constraints are not
satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Converged to an infeasible point.

fmincon stopped because it is unable to find a point locally that satisfies
the constraints within the value of the constraint tolerance.


Solving problem using fmincon.

Converged to an infeasible point.

fmincon stopped because the size of the current step is less than
the value of the step size tolerance but constraints are not
satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Converged to an infeasible point.

fmincon stopped because the size of the current step is less than
the value of the step size tolerance but constraints are not
satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Converged to an infeasible point.

fmincon stopped because the size of the current step is less than
the value of the step size tolerance but constraints are not
satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.


Solving problem using fmincon.

Local minimum found that satisfies the constraints.

Optimization completed because the objective function is non-decreasing in 
feasible directions, to within the value of the optimality tolerance,
and constraints are satisfied to within the value of the constraint tolerance.

</pre><h2 id="11">Getting the optimal UAV locations for the UAV Relays</h2><pre class="codeinput"><span class="comment">% Two are required as we can have two optimal locations.</span>
uav_1 = [];
uav_2 = [];

<span class="comment">% Parameters that can be changed according to the experiments.</span>
x_bs = mean(centroids(:, 1));
y_bs = mean(centroids(:, 2));
P_bs = 50;
P_uav = power_threshold;
bw_bs = 10;
bw_uav  = 5;
h_relay= 1;
h_bs = 0.1;
capacity_thresh = 1;

<span class="keyword">for</span> i=1:num_of_centroids
    points = optimal_points(x_bs, y_bs, centroids(i,1), centroids(i,2), <span class="keyword">...</span>
        P_bs, P_uav, bw_bs, bw_uav, optimal_data(i,2), h_bs, h_relay, <span class="keyword">...</span>
        capacity_thresh, var_n);
    uav_1 = [uav_1; points(1, :)];
    uav_2 = [uav_2; points(2, :)];
<span class="keyword">end</span>
</pre><h2 id="12">Plotting the Ranges of all the UAVs</h2><pre class="codeinput">c_data = [128, 152, 237]/256;
c_bs_range = [244, 91, 105]/256;
c_uav_1 = [92, 91, 110] / 256;
c_uav_2 = [128, 194, 103] / 256;

figure(<span class="string">'Name'</span>, <span class="string">'Communication Ranges'</span>, <span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>, <span class="keyword">...</span>
    [0 0 1 1]);

<span class="comment">% Finds the radius of coverage of the UAVs and plots them</span>
syms <span class="string">d_uav</span>;
capacity_uav = bw_uav*log(1 + P_uav/((d_uav^2 + (height_threshold)^2)*var_n));
eqn = capacity_uav == capacity_thresh;
r_uav = solve(eqn, d_uav);
r_uav = abs(r_uav(1,1));
th = 0:pi/50:2*pi;
<span class="keyword">for</span> i=1:num_of_centroids
    x_circle_uav = centroids(i, 1) + r_uav * cos(th);
    y_circle_uav = centroids(i, 2) + r_uav * sin(th);
    plot(x_circle_uav, y_circle_uav, <span class="string">'Color'</span>, c_bs_range);
    hold <span class="string">on</span>;
<span class="keyword">end</span>

<span class="comment">% Finds the radius of the coverage of the base station and plots them.</span>
syms <span class="string">x</span>
capacity_bs = bw_bs*log(1 + P_bs/((x^2 + (h_bs)^2)*var_n));
eqn = capacity_bs == capacity_thresh;
r_bs = solve(eqn, x);
r_bs = abs(r_bs(1,1));
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, <span class="string">'Color'</span>, c_bs_range);
hold <span class="string">on</span>;

<span class="comment">% Getting the labels for the UAV</span>
numbered_labelling_uav = (2:41)';
numbered_labelling_uav = num2str(numbered_labelling_uav);
numbered_labelling_bs = <span class="string">'1'</span>;
dx = 0.8; dy = 0.8; <span class="comment">% Displacement so the text does not overlay the data points</span>

<span class="comment">% Plotting the UAV Data</span>
p_uav_1 = scatter(uav_1(:,1), uav_1(:,2), 70, c_uav_1, <span class="string">'^'</span>, <span class="string">'filled'</span>);
hold <span class="string">on</span>;
p_uav_2 = scatter(uav_2(:,1), uav_2(:,2), 40, c_uav_2, <span class="string">'^'</span>, <span class="string">'filled'</span>);
hold <span class="string">on</span>;
p_centroid = plot(centroids(:,1), centroids(:,2), <span class="string">'kx'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="keyword">...</span>
    <span class="string">'LineWidth'</span>, 3, <span class="string">'DisplayName'</span>, <span class="string">'Centroids'</span>);
hold <span class="string">on</span>;
p_center = plot(x_bs, y_bs, <span class="string">'ks'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="string">'LineWidth'</span>, 3);
hold <span class="string">off</span>;
axis <span class="string">equal</span>;

legend([p_centroid, p_uav_1, p_uav_2, p_center], <span class="string">'Centroids'</span>, <span class="keyword">...</span>
    <span class="string">'UAV Intersection 1'</span>, <span class="string">'UAV Intersection 2'</span>, <span class="string">'Base Station'</span>);
title(<span class="string">'Communication Ranges'</span>);
xlabel(<span class="string">'X Distance'</span>);
ylabel(<span class="string">'Y Distance'</span>);
text(centroids(:,1) + dx, centroids(:,2) + dy, numbered_labelling_uav);
text(x_bs + dx, y_bs + dy, numbered_labelling_bs);
</pre><img vspace="5" hspace="5" src="uav_placement_05.png" alt=""> <h2 id="13">Plotting the Population Density</h2><pre class="codeinput">figure(<span class="string">'Name'</span>, <span class="string">'Population Density'</span>, <span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>, <span class="keyword">...</span>
    [0 0 1 1]);

<span class="comment">% Finds the radius of the coverage of the base station and plots them.</span>
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, <span class="string">'Color'</span>, c_bs_range);
hold <span class="string">on</span>;

<span class="comment">% Plotting the user data, the UAV data and the base Station Data</span>
users = scatter(X, Y, [], c_data, <span class="string">'.'</span>);
hold <span class="string">on</span>;
p_center = plot(x_bs, y_bs, <span class="string">'ks'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="string">'LineWidth'</span>, 3);
hold <span class="string">off</span>;
axis <span class="string">equal</span>;

legend([p_center, users], <span class="string">'Base Station'</span>, <span class="string">'Users'</span>);
title(<span class="string">'Population Density'</span>);
xlabel(<span class="string">'X Distance'</span>);
ylabel(<span class="string">'Y Distance'</span>);
</pre><img vspace="5" hspace="5" src="uav_placement_06.png" alt=""> <h2 id="14">Plotting the optimal UAV Placement Locations</h2><pre class="codeinput">figure(<span class="string">'Name'</span>, <span class="string">'Optimal UAV Placement'</span>, <span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>, <span class="keyword">...</span>
    [0 0 1 1]);

<span class="comment">% Finds the radius of the coverage of the base station and plots them.</span>
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, <span class="string">'Color'</span>, c_bs_range);
hold <span class="string">on</span>;

<span class="comment">% Plotting the user data, the UAV data and the base Station Data</span>
users = scatter(X, Y, [], c_data, <span class="string">'.'</span>);
hold <span class="string">on</span>;
p_centroid = plot(centroids(:,1), centroids(:,2), <span class="string">'kx'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="keyword">...</span>
    <span class="string">'LineWidth'</span>, 3, <span class="string">'DisplayName'</span>, <span class="string">'Centroids'</span>);
hold <span class="string">on</span>;
p_uav_1 = scatter(uav_1(:,1), uav_1(:,2), 70, c_uav_1, <span class="string">'^'</span>, <span class="string">'filled'</span>);
hold <span class="string">on</span>;
p_uav_2 = scatter(uav_2(:,1), uav_2(:,2), 40, c_uav_2, <span class="string">'^'</span>, <span class="string">'filled'</span>);
hold <span class="string">on</span>;
p_center = plot(x_bs, y_bs, <span class="string">'ks'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="string">'LineWidth'</span>, 3);
hold <span class="string">off</span>;
axis <span class="string">equal</span>;

legend([p_centroid, p_uav_1, p_uav_2, p_center, users], <span class="string">'Centroids'</span>, <span class="keyword">...</span>
    <span class="string">'UAV Intersection 1'</span>, <span class="string">'UAV Intersection 2'</span>, <span class="string">'Base Station'</span>, <span class="string">'Users'</span>);
title(<span class="string">'Optimal UAV Placement'</span>);
xlabel(<span class="string">'X Distance'</span>);
ylabel(<span class="string">'Y Distance'</span>);
text(centroids(:,1) + dx, centroids(:,2) + dy, numbered_labelling_uav);
text(x_bs + dx, y_bs + dy, numbered_labelling_bs);
</pre><img vspace="5" hspace="5" src="uav_placement_07.png" alt=""> <img vspace="5" hspace="5" src="uav_placement_08.png" alt=""> <h2 id="15">Comparing the Utility of K-Means vs Random Placement by checking Total Channel Capacity and Number of Users served.</h2><pre class="codeinput"><span class="comment">% Computing the Random Placement Capacity</span>
total_random_channel_cap = 0;
total_random_users_served = 0;
<span class="keyword">for</span> i=1:num_of_centroids
    dist = (data(:,1) - random_centroids(i, 1)).^2 + (data(:,2) - <span class="keyword">...</span>
        random_centroids(i, 2)).^2;
    total_random_channel_cap  = total_random_channel_cap + sum(bw_uav * log(1 + <span class="keyword">...</span>
        P_uav./(((dist + optimal_data(i,2)^2))*var_n)));
    total_random_users_served = total_random_users_served + sum(bw_uav * log(1 + <span class="keyword">...</span>
        P_uav./((dist + optimal_data(i,2)^2)*var_n))&gt;chan_capacity_thresh);
<span class="keyword">end</span>

<span class="comment">% Computing the Total Channel Capacity.</span>
total_channel_cap_opt = 0;
total_optimal_users_served = 0;
<span class="keyword">for</span> i=1:num_of_centroids
    dist = (data(:,1) - centroids(i, 1)).^2 + (data(:,2) - centroids(i, 2)).^2;
    total_channel_cap_opt  = total_channel_cap_opt + sum(bw_uav * log(1 + <span class="keyword">...</span>
        optimal_data(i,1)./(((dist + optimal_data(i,2)^2))*var_n)));
    total_optimal_users_served = total_optimal_users_served + sum(bw_uav * log(1 + <span class="keyword">...</span>
        P_uav./((dist + optimal_data(i,2)^2)*var_n))&gt;chan_capacity_thresh);
<span class="keyword">end</span>

fprintf(<span class="string">'Random Placement\n'</span>);
fprintf(<span class="string">'Total Channel Capacity: %f \n'</span>, total_random_channel_cap);
fprintf(<span class="string">'Channel Capacity Per User: %f \n'</span>, total_random_channel_cap/no_of_users);
fprintf(<span class="string">'Users Served: %f \n'</span>, total_random_users_served);
perc_random_users_served = (total_random_users_served / no_of_users) * 100 <span class="keyword">...</span>
    * (total_random_users_served&lt;no_of_users) + 100*~(total_random_users_served&lt;no_of_users);
fprintf(<span class="string">'Percentage of Users Served: %f \n\n'</span>, perc_random_users_served);

fprintf(<span class="string">'Optimal Placement\n'</span>);
fprintf(<span class="string">'Total Channel Capacity: %f \n'</span>, total_channel_cap_opt);
fprintf(<span class="string">'Channel Capacity Per User: %f \n'</span>, total_channel_cap_opt/no_of_users);
fprintf(<span class="string">'Users Served: %f \n'</span>, sum(optimal_data(:, 4)));
perc_opt_users_served = (sum(optimal_data(:, 4)) / no_of_users) * 100;
fprintf(<span class="string">'Percentage of Users Served: %f \n\n'</span>, perc_opt_users_served);

fprintf(<span class="string">'Amount of Energy Saved: %f \n'</span>, <span class="keyword">...</span>
    sum((power_threshold - optimal_data(:, 1)) .* optimal_data(:, 4)));
fprintf(<span class="string">'Percentage of Energy Saved: %f \n'</span>, <span class="keyword">...</span>
    sum((power_threshold - optimal_data(:, 1)) .* optimal_data(:, 4)) / <span class="keyword">...</span>
    (no_of_users * power_threshold) * 100)
</pre><pre class="codeoutput">Random Placement
Total Channel Capacity: 33953.624262 
Channel Capacity Per User: 8.488406 
Users Served: 5829.000000 
Percentage of Users Served: 100.000000 

Optimal Placement
Total Channel Capacity: 39441.820256 
Channel Capacity Per User: 9.860455 
Users Served: 3993.000000 
Percentage of Users Served: 99.825000 

Amount of Energy Saved: 18087.842495 
Percentage of Energy Saved: 45.219606 
</pre><h2 id="16">Using Graph Theory to get the Shortest Distance between Nodes</h2><pre class="codeinput"><span class="comment">% Assigning different weights to wireless communication and UAV travel</span>
w_com = 1; <span class="comment">% Energy required for communication</span>
w_mot = 5; <span class="comment">% Energy required for motion</span>

<span class="comment">% Generating the Graph (Adjacency matrix)</span>

G = zeros(num_of_centroids + 1, num_of_centroids + 1);
bs_and_cent = [x_bs, y_bs; centroids];

<span class="keyword">for</span> i=1:41
    <span class="keyword">for</span> j=1:41

        <span class="keyword">if</span> (i==j)
            G(i, j) = 0;
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>

        <span class="keyword">if</span> (i==1 || j==1)
            r1 = r_bs;
            r2 = r_uav;
        <span class="keyword">else</span>
            r1 = r_uav;
            r2 = r_uav;
        <span class="keyword">end</span>

        dist = sqrt((bs_and_cent(i,1) - bs_and_cent(j,1))^2 + <span class="keyword">...</span>
            (bs_and_cent(i,2) - bs_and_cent(j,2))^2);

        <span class="keyword">if</span> (dist &gt;= r1 + r2)
            G(i, j) = (dist - r1 - r2) * w_mot + (r1 + r2) * w_com;
        <span class="keyword">else</span>
            G(i, j) = dist * w_com;
        <span class="keyword">end</span>

    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Calculating the cost as well as the routes for the Graph and get the</span>
<span class="comment">% updated optimal UAV locations.</span>
cost_and_routes = zeros(40, 42);

uav_1_updated = [];
uav_2_updated = [];

fprintf(<span class="string">'\n'</span>);

<span class="keyword">for</span> i=1:40
    [cost, routes] = dijkstra(G, 1, i+1);

    <span class="keyword">if</span> (size(routes, 2)==2)
        points = optimal_points(x_bs, y_bs, centroids(i,1), centroids(i,2), <span class="keyword">...</span>
            P_bs, P_uav, bw_bs, bw_uav, optimal_data(i,2), h_bs, h_relay, <span class="keyword">...</span>
            capacity_thresh, var_n);
        uav_1_updated = [uav_1_updated; points(1, :)];
        uav_2_updated = [uav_2_updated; points(2, :)];
    <span class="keyword">end</span>

    <span class="keyword">if</span> (size(routes,2)&gt;2)
        fprintf(<span class="string">'Route 1 to %i: '</span>, i+1);
    <span class="keyword">end</span>

    <span class="keyword">for</span> j=1:size(routes, 2)
        <span class="keyword">if</span> (size(routes,2)&gt;2)
            fprintf(<span class="string">'%i '</span>, routes(1, j));
            <span class="keyword">if</span> (j&lt;(size(routes, 2)-1))
                <span class="comment">% We substract 1 as the first UAV starts from 2</span>
                uav_index_1 = routes(1, j)-1;
                uav_index_2 = routes(1, j+1)-1;
                points = optimal_points(centroids(uav_index_1, 1), <span class="keyword">...</span>
                    centroids(uav_index_1, 2), centroids(uav_index_2, 1), <span class="keyword">...</span>
                    centroids(uav_index_2, 2), P_uav, P_uav, bw_uav, <span class="keyword">...</span>
                    bw_uav, optimal_data(j, 2), optimal_data(j+1, 2), h_relay, <span class="keyword">...</span>
                    capacity_thresh, var_n);
                uav_1_updated = [uav_1_updated; points(1, :)];
                uav_2_updated = [uav_2_updated; points(2, :)];
            <span class="keyword">elseif</span> (j==(size(routes, 2)-1))
                uav_index_1 = routes(1, j) - 1;
                points = optimal_points(x_bs, y_bs, centroids(uav_index_1,1), <span class="keyword">...</span>
                    centroids(uav_index_1,2), P_bs, P_uav, bw_bs, bw_uav, <span class="keyword">...</span>
                    optimal_data(j,2), h_bs, h_relay, capacity_thresh, var_n);
                uav_1_updated = [uav_1_updated; points(1, :)];
                uav_2_updated = [uav_2_updated; points(2, :)];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        cost_and_routes(i, j) = routes(1, j);
        cost_and_routes(i, 42) = cost;
    <span class="keyword">end</span>

    <span class="keyword">if</span> (size(routes,2)&gt;2)
        fprintf(<span class="string">'\n'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
Route 1 to 3: 3 21 1 
Route 1 to 9: 9 41 1 
Route 1 to 14: 14 25 1 
Route 1 to 15: 15 13 1 
Route 1 to 26: 26 11 1 
Route 1 to 29: 29 20 1 
Route 1 to 31: 31 38 1 
Route 1 to 32: 32 36 1 
Route 1 to 40: 40 6 1 
</pre><h2 id="17">Plotting the Updated Ranges of all the UAVs</h2><pre class="codeinput">figure(<span class="string">'Name'</span>, <span class="string">'Updated Communication Ranges'</span>, <span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>, <span class="keyword">...</span>
    [0 0 1 1]);

<span class="comment">% Finds the radius of coverage of the UAVs and plots them</span>
th = 0:pi/50:2*pi;
<span class="keyword">for</span> i=1:num_of_centroids
    x_circle_uav = centroids(i, 1) + r_uav * cos(th);
    y_circle_uav = centroids(i, 2) + r_uav * sin(th);
    plot(x_circle_uav, y_circle_uav, <span class="string">'Color'</span>, c_bs_range);
    hold <span class="string">on</span>;
<span class="keyword">end</span>

<span class="comment">% Finds the radius of the coverage of the base station and plots them.</span>
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, <span class="string">'Color'</span>, c_bs_range);
hold <span class="string">on</span>;

<span class="comment">% Getting the labels for the UAV</span>
numbered_labelling_uav = (2:41)';
numbered_labelling_uav = num2str(numbered_labelling_uav);
numbered_labelling_bs = <span class="string">'1'</span>;
dx = 0.8; dy = 0.8; <span class="comment">% Displacement so the text does not overlay the data points</span>

<span class="comment">% Plotting the user data, the UAV data and the base Station Data</span>
users = scatter(X, Y, [], c_data, <span class="string">'.'</span>);
hold <span class="string">on</span>;
p_centroid = plot(centroids(:,1), centroids(:,2), <span class="string">'kx'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="keyword">...</span>
    <span class="string">'LineWidth'</span>, 3, <span class="string">'DisplayName'</span>, <span class="string">'Centroids'</span>);
hold <span class="string">on</span>;
p_uav_1 = scatter(uav_1_updated(:,1), uav_1_updated(:,2), 70, c_uav_1, <span class="string">'^'</span>, <span class="string">'filled'</span>);
hold <span class="string">on</span>;
p_uav_2 = scatter(uav_2_updated(:,1), uav_2_updated(:,2), 40, c_uav_2, <span class="string">'^'</span>, <span class="string">'filled'</span>);
hold <span class="string">on</span>;
p_center = plot(x_bs, y_bs, <span class="string">'ks'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="string">'LineWidth'</span>, 3);
hold <span class="string">off</span>;
axis <span class="string">equal</span>;

legend([p_centroid, p_uav_1, p_uav_2, p_center], <span class="string">'Centroids'</span>, <span class="keyword">...</span>
    <span class="string">'UAV Intersection 1'</span>, <span class="string">'UAV Intersection 2'</span>, <span class="string">'Base Station'</span>);
title(<span class="string">'Communication Ranges'</span>);
xlabel(<span class="string">'X Distance'</span>);
ylabel(<span class="string">'Y Distance'</span>);
text(centroids(:,1) + dx, centroids(:,2) + dy, numbered_labelling_uav);
text(x_bs + dx, y_bs + dy, numbered_labelling_bs);
</pre><img vspace="5" hspace="5" src="uav_placement_09.png" alt=""> <img vspace="5" hspace="5" src="uav_placement_10.png" alt=""> <h2 id="18">Plotting the updated optimal UAV Placement Locations</h2><pre class="codeinput">figure(<span class="string">'Name'</span>, <span class="string">'Updated Optimal UAV Placement'</span>, <span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="keyword">...</span>
    <span class="string">'outerposition'</span>, [0 0 1 1]);

<span class="comment">% Finds the radius of the coverage of the base station and plots them.</span>
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, <span class="string">'Color'</span>, c_bs_range);
hold <span class="string">on</span>;

<span class="comment">% Plotting the user data, the UAV data and the base Station Data</span>
users = scatter(X, Y, [], c_data, <span class="string">'.'</span>);
hold <span class="string">on</span>;
p_centroid = plot(centroids(:,1), centroids(:,2), <span class="string">'kx'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="keyword">...</span>
    <span class="string">'LineWidth'</span>, 3, <span class="string">'DisplayName'</span>, <span class="string">'Centroids'</span>);
hold <span class="string">on</span>;
p_uav_1 = scatter(uav_1_updated(:,1), uav_1_updated(:,2), 70, c_uav_1, <span class="string">'^'</span>, <span class="string">'filled'</span>);
hold <span class="string">on</span>;
p_uav_2 = scatter(uav_2_updated(:,1), uav_2_updated(:,2), 40, c_uav_2, <span class="string">'^'</span>, <span class="string">'filled'</span>);
hold <span class="string">on</span>;
p_center = plot(x_bs, y_bs, <span class="string">'ks'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="string">'LineWidth'</span>, 3);
hold <span class="string">off</span>;
axis <span class="string">equal</span>;

legend([p_centroid, p_uav_1, p_uav_2, p_center, users], <span class="string">'Centroids'</span>, <span class="keyword">...</span>
    <span class="string">'UAV Intersection 1'</span>, <span class="string">'UAV Intersection 2'</span>, <span class="string">'Base Station'</span>, <span class="string">'Users'</span>);
title(<span class="string">'Updated Optimal UAV Placement'</span>);
xlabel(<span class="string">'X Distance'</span>);
ylabel(<span class="string">'Y Distance'</span>);
text(centroids(:,1) + dx, centroids(:,2) + dy, numbered_labelling_uav);
text(x_bs + dx, y_bs + dy, numbered_labelling_bs);
</pre><img vspace="5" hspace="5" src="uav_placement_11.png" alt=""> <h2 id="19">Calculating the Performance Metrics for the Dijkstra Algorithm</h2><pre class="codeinput">dist_matrix_orig = (uav_1 - uav_2)' * (uav_1 - uav_2);
dist_matrix_updated = (uav_1_updated - uav_2_updated)' * <span class="keyword">...</span>
    (uav_1_updated - uav_2_updated);

latency_reduced_per = (dist_matrix_orig(1, 1) + dist_matrix_orig(2, 2) - <span class="keyword">...</span>
    dist_matrix_updated(1,1) - dist_matrix_updated(2, 2)) / <span class="keyword">...</span>
    (dist_matrix_orig(1, 1) + dist_matrix_orig(2, 2)) * 100;

additional_energy_saved = (dist_matrix_orig(1, 1) + dist_matrix_orig(2, 2) - <span class="keyword">...</span>
    dist_matrix_updated(1,1) - dist_matrix_updated(2, 2)) * w_mot;

fprintf(<span class="string">'\n'</span>);
fprintf(<span class="string">'Percentage Latency Reduced: %f \n'</span>, latency_reduced_per);
fprintf(<span class="string">'Additional Energy Saved: %f \n'</span>, additional_energy_saved);
</pre><pre class="codeoutput">
Percentage Latency Reduced: 98.454982 
Additional Energy Saved: 1272.377566 
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Creating a new environment

clc;
clear all;
close all;

%% Functions Created: generate_data
% <include>generate_data.m</include>

%% Functions Created: optimal_points
% <include>optimal_points.m</include>

%% Functions Created: optimal_points
% <include>optimize_pow_height_cluster.m</include>

%% Generating the data from each of the 2D Gaussian Distributions.

% Parameters that can be changed according to the experiments.
num_of_clusters = 40;  
start_range_mean = -40;
end_range_mean = 40;
start_range_var = 0;
end_range_var =  10;
data_points_per_cluster = 100;
no_of_users = num_of_clusters * data_points_per_cluster;

% Calling the generate_data function.
data = generate_data(num_of_clusters, start_range_mean, end_range_mean, ...
    start_range_var, end_range_var, data_points_per_cluster);

X = data(:, 1);
Y = data(: ,2);

%% Plotting each of the Gaussian Dsitributions.

figure('Name', 'Gaussian Clusters', 'units','normalized','outerposition', ...
    [0 0 1 1]);
for i=1:num_of_clusters
    plot(data((i-1)*100 + 1: (i)*100, 1), data((i-1)*100 + 1: (i)*100, 2), '.');
    hold on;
end

hold off;
title('Gaussian Distributions');
xlabel('X Distance');
ylabel('Y Distance');


%% Getting the K-Means Centroids and Clusters

num_of_centroids = 40;
[idx, centroids] = kmeans(data, num_of_centroids);

% Getting the Clusters Associated with each centroid.
k_means_clusters = cell(num_of_centroids, 1);
for i = 1:num_of_centroids
    k_means_clusters{i} = [X(idx==i),Y(idx==i)] ;
end

%% Generating Random Points for Placing the the Random UAVs

start_range_random = start_range_mean - sqrt(end_range_var);
end_range_random = end_range_mean + sqrt(end_range_var);
X_random = start_range_random + (end_range_random - start_range_random) * ... 
    rand(num_of_clusters, 1);
Y_random = start_range_random + (end_range_random - start_range_random) * ...
    rand(num_of_clusters, 1);
random_centroids = [X_random, Y_random];

figure('Name', 'Random Centroids', 'units','normalized','outerposition', ...
    [0 0 1 1]);

gscatter(X, Y, idx);
hold on;
p_centroids_random = plot(random_centroids(:,1), random_centroids(:,2), ...
    'kx', 'MarkerSize', 15, 'LineWidth', 3, 'DisplayName','Random Centroids'); 
hold off;

legend([p_centroids_random], 'Random Centroids');
title('Random Centroids');
xlabel('X Distance');
ylabel('Y Distance');

%% Plotting the K-Means Centroids

figure('Name', 'K Means Centroids', 'units','normalized','outerposition', ...
    [0 0 1 1]);

gscatter(X, Y, idx);
hold on;
p_centroids = plot(centroids(:,1), centroids(:,2), 'kx', 'MarkerSize', ...
    15, 'LineWidth', 3, 'DisplayName','Centroids'); 
hold off;

legend([p_centroids], 'Centroids');
title('K Means Centroids');
xlabel('X Distance');
ylabel('Y Distance');


%% Getting the optimal UAV power, height, coverage area, and the users served per Cluster

% The five columns are optimal power, optimal height, radius of the users
% served, number of users served
optimal_data = zeros(num_of_centroids, 5);
power_threshold = 10;
height_threshold = 0.5;
bw_uav  = 5;
alpha = 0.5;
chan_capacity_thresh = 1;
var_n = 0.5;

for i=1:num_of_centroids
    [optimal_data(i,1), optimal_data(i,2), optimal_data(i,3), ...
        optimal_data(i,4), optimal_data(i,5)] = ...
        optimize_pow_height_cluster(k_means_clusters{i}, centroids(i,:), ...
        power_threshold, height_threshold, alpha, chan_capacity_thresh, bw_uav, ...
        var_n);
end

%% Getting the optimal UAV locations for the UAV Relays

% Two are required as we can have two optimal locations. 
uav_1 = [];
uav_2 = [];

% Parameters that can be changed according to the experiments.
x_bs = mean(centroids(:, 1));
y_bs = mean(centroids(:, 2));
P_bs = 50;
P_uav = power_threshold;
bw_bs = 10;
bw_uav  = 5;
h_relay= 1;
h_bs = 0.1;
capacity_thresh = 1;

for i=1:num_of_centroids
    points = optimal_points(x_bs, y_bs, centroids(i,1), centroids(i,2), ...
        P_bs, P_uav, bw_bs, bw_uav, optimal_data(i,2), h_bs, h_relay, ...
        capacity_thresh, var_n);
    uav_1 = [uav_1; points(1, :)];
    uav_2 = [uav_2; points(2, :)];
end

%% Plotting the Ranges of all the UAVs

c_data = [128, 152, 237]/256;
c_bs_range = [244, 91, 105]/256;
c_uav_1 = [92, 91, 110] / 256;
c_uav_2 = [128, 194, 103] / 256;

figure('Name', 'Communication Ranges', 'units','normalized','outerposition', ...
    [0 0 1 1]);

% Finds the radius of coverage of the UAVs and plots them
syms d_uav;
capacity_uav = bw_uav*log(1 + P_uav/((d_uav^2 + (height_threshold)^2)*var_n));
eqn = capacity_uav == capacity_thresh;
r_uav = solve(eqn, d_uav);
r_uav = abs(r_uav(1,1));
th = 0:pi/50:2*pi;
for i=1:num_of_centroids
    x_circle_uav = centroids(i, 1) + r_uav * cos(th);
    y_circle_uav = centroids(i, 2) + r_uav * sin(th);
    plot(x_circle_uav, y_circle_uav, 'Color', c_bs_range);
    hold on;
end

% Finds the radius of the coverage of the base station and plots them.
syms x
capacity_bs = bw_bs*log(1 + P_bs/((x^2 + (h_bs)^2)*var_n));
eqn = capacity_bs == capacity_thresh;
r_bs = solve(eqn, x);
r_bs = abs(r_bs(1,1));
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, 'Color', c_bs_range);
hold on;

% Getting the labels for the UAV
numbered_labelling_uav = (2:41)';
numbered_labelling_uav = num2str(numbered_labelling_uav);
numbered_labelling_bs = '1';
dx = 0.8; dy = 0.8; % Displacement so the text does not overlay the data points

% Plotting the UAV Data
p_uav_1 = scatter(uav_1(:,1), uav_1(:,2), 70, c_uav_1, '^', 'filled');
hold on;
p_uav_2 = scatter(uav_2(:,1), uav_2(:,2), 40, c_uav_2, '^', 'filled');
hold on;
p_centroid = plot(centroids(:,1), centroids(:,2), 'kx', 'MarkerSize', 10, ...
    'LineWidth', 3, 'DisplayName', 'Centroids'); 
hold on;
p_center = plot(x_bs, y_bs, 'ks', 'MarkerSize', 10, 'LineWidth', 3);
hold off;
axis equal;

legend([p_centroid, p_uav_1, p_uav_2, p_center], 'Centroids', ... 
    'UAV Intersection 1', 'UAV Intersection 2', 'Base Station');
title('Communication Ranges');
xlabel('X Distance');
ylabel('Y Distance');
text(centroids(:,1) + dx, centroids(:,2) + dy, numbered_labelling_uav);
text(x_bs + dx, y_bs + dy, numbered_labelling_bs);

%% Plotting the Population Density

figure('Name', 'Population Density', 'units','normalized','outerposition', ...
    [0 0 1 1]);

% Finds the radius of the coverage of the base station and plots them.
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, 'Color', c_bs_range);
hold on;

% Plotting the user data, the UAV data and the base Station Data
users = scatter(X, Y, [], c_data, '.');
hold on;
p_center = plot(x_bs, y_bs, 'ks', 'MarkerSize', 10, 'LineWidth', 3);
hold off;
axis equal;

legend([p_center, users], 'Base Station', 'Users');
title('Population Density');
xlabel('X Distance');
ylabel('Y Distance');


%% Plotting the optimal UAV Placement Locations

figure('Name', 'Optimal UAV Placement', 'units','normalized','outerposition', ...
    [0 0 1 1]);

% Finds the radius of the coverage of the base station and plots them.
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, 'Color', c_bs_range);
hold on;

% Plotting the user data, the UAV data and the base Station Data
users = scatter(X, Y, [], c_data, '.');
hold on;
p_centroid = plot(centroids(:,1), centroids(:,2), 'kx', 'MarkerSize', 10, ...
    'LineWidth', 3, 'DisplayName', 'Centroids'); 
hold on;
p_uav_1 = scatter(uav_1(:,1), uav_1(:,2), 70, c_uav_1, '^', 'filled');
hold on;
p_uav_2 = scatter(uav_2(:,1), uav_2(:,2), 40, c_uav_2, '^', 'filled');
hold on;
p_center = plot(x_bs, y_bs, 'ks', 'MarkerSize', 10, 'LineWidth', 3);
hold off;
axis equal;

legend([p_centroid, p_uav_1, p_uav_2, p_center, users], 'Centroids', ... 
    'UAV Intersection 1', 'UAV Intersection 2', 'Base Station', 'Users');
title('Optimal UAV Placement');
xlabel('X Distance');
ylabel('Y Distance');
text(centroids(:,1) + dx, centroids(:,2) + dy, numbered_labelling_uav);
text(x_bs + dx, y_bs + dy, numbered_labelling_bs);

%% Comparing the Utility of K-Means vs Random Placement by checking Total Channel Capacity and Number of Users served.

% Computing the Random Placement Capacity
total_random_channel_cap = 0;
total_random_users_served = 0;
for i=1:num_of_centroids
    dist = (data(:,1) - random_centroids(i, 1)).^2 + (data(:,2) - ... 
        random_centroids(i, 2)).^2;
    total_random_channel_cap  = total_random_channel_cap + sum(bw_uav * log(1 + ... 
        P_uav./(((dist + optimal_data(i,2)^2))*var_n)));
    total_random_users_served = total_random_users_served + sum(bw_uav * log(1 + ...
        P_uav./((dist + optimal_data(i,2)^2)*var_n))>chan_capacity_thresh); 
end

% Computing the Total Channel Capacity.
total_channel_cap_opt = 0;
total_optimal_users_served = 0;
for i=1:num_of_centroids
    dist = (data(:,1) - centroids(i, 1)).^2 + (data(:,2) - centroids(i, 2)).^2;
    total_channel_cap_opt  = total_channel_cap_opt + sum(bw_uav * log(1 + ... 
        optimal_data(i,1)./(((dist + optimal_data(i,2)^2))*var_n)));
    total_optimal_users_served = total_optimal_users_served + sum(bw_uav * log(1 + ...
        P_uav./((dist + optimal_data(i,2)^2)*var_n))>chan_capacity_thresh);    
end

fprintf('Random Placement\n');
fprintf('Total Channel Capacity: %f \n', total_random_channel_cap);
fprintf('Channel Capacity Per User: %f \n', total_random_channel_cap/no_of_users);
fprintf('Users Served: %f \n', total_random_users_served);
perc_random_users_served = (total_random_users_served / no_of_users) * 100 ...
    * (total_random_users_served<no_of_users) + 100*~(total_random_users_served<no_of_users);
fprintf('Percentage of Users Served: %f \n\n', perc_random_users_served);

fprintf('Optimal Placement\n');
fprintf('Total Channel Capacity: %f \n', total_channel_cap_opt);
fprintf('Channel Capacity Per User: %f \n', total_channel_cap_opt/no_of_users);
fprintf('Users Served: %f \n', sum(optimal_data(:, 4)));
perc_opt_users_served = (sum(optimal_data(:, 4)) / no_of_users) * 100;
fprintf('Percentage of Users Served: %f \n\n', perc_opt_users_served);

fprintf('Amount of Energy Saved: %f \n', ... 
    sum((power_threshold - optimal_data(:, 1)) .* optimal_data(:, 4)));
fprintf('Percentage of Energy Saved: %f \n', ...
    sum((power_threshold - optimal_data(:, 1)) .* optimal_data(:, 4)) / ...
    (no_of_users * power_threshold) * 100)

%% Using Graph Theory to get the Shortest Distance between Nodes


% Assigning different weights to wireless communication and UAV travel
w_com = 1; % Energy required for communication
w_mot = 5; % Energy required for motion

% Generating the Graph (Adjacency matrix)

G = zeros(num_of_centroids + 1, num_of_centroids + 1);
bs_and_cent = [x_bs, y_bs; centroids]; 

for i=1:41
    for j=1:41
        
        if (i==j)
            G(i, j) = 0;
            continue;
        end
        
        if (i==1 || j==1)
            r1 = r_bs;
            r2 = r_uav;
        else
            r1 = r_uav;
            r2 = r_uav;
        end
        
        dist = sqrt((bs_and_cent(i,1) - bs_and_cent(j,1))^2 + ...
            (bs_and_cent(i,2) - bs_and_cent(j,2))^2);
        
        if (dist >= r1 + r2)
            G(i, j) = (dist - r1 - r2) * w_mot + (r1 + r2) * w_com;
        else
            G(i, j) = dist * w_com;
        end
                
    end
end

% Calculating the cost as well as the routes for the Graph and get the 
% updated optimal UAV locations.
cost_and_routes = zeros(40, 42);

uav_1_updated = [];
uav_2_updated = [];

fprintf('\n');

for i=1:40
    [cost, routes] = dijkstra(G, 1, i+1);
    
    if (size(routes, 2)==2)
        points = optimal_points(x_bs, y_bs, centroids(i,1), centroids(i,2), ...
            P_bs, P_uav, bw_bs, bw_uav, optimal_data(i,2), h_bs, h_relay, ...
            capacity_thresh, var_n);
        uav_1_updated = [uav_1_updated; points(1, :)];
        uav_2_updated = [uav_2_updated; points(2, :)];
    end
    
    if (size(routes,2)>2)
        fprintf('Route 1 to %i: ', i+1);
    end
    
    for j=1:size(routes, 2)
        if (size(routes,2)>2)
            fprintf('%i ', routes(1, j));
            if (j<(size(routes, 2)-1))
                % We substract 1 as the first UAV starts from 2
                uav_index_1 = routes(1, j)-1; 
                uav_index_2 = routes(1, j+1)-1; 
                points = optimal_points(centroids(uav_index_1, 1), ...
                    centroids(uav_index_1, 2), centroids(uav_index_2, 1), ...
                    centroids(uav_index_2, 2), P_uav, P_uav, bw_uav, ...
                    bw_uav, optimal_data(j, 2), optimal_data(j+1, 2), h_relay, ...
                    capacity_thresh, var_n);
                uav_1_updated = [uav_1_updated; points(1, :)];
                uav_2_updated = [uav_2_updated; points(2, :)];
            elseif (j==(size(routes, 2)-1))
                uav_index_1 = routes(1, j) - 1;
                points = optimal_points(x_bs, y_bs, centroids(uav_index_1,1), ...
                    centroids(uav_index_1,2), P_bs, P_uav, bw_bs, bw_uav, ...
                    optimal_data(j,2), h_bs, h_relay, capacity_thresh, var_n);
                uav_1_updated = [uav_1_updated; points(1, :)];
                uav_2_updated = [uav_2_updated; points(2, :)];
            end
        end
        cost_and_routes(i, j) = routes(1, j);
        cost_and_routes(i, 42) = cost;
    end
    
    if (size(routes,2)>2)
        fprintf('\n');
    end          
end
%% Plotting the Updated Ranges of all the UAVs

figure('Name', 'Updated Communication Ranges', 'units','normalized','outerposition', ...
    [0 0 1 1]);

% Finds the radius of coverage of the UAVs and plots them
th = 0:pi/50:2*pi;
for i=1:num_of_centroids
    x_circle_uav = centroids(i, 1) + r_uav * cos(th);
    y_circle_uav = centroids(i, 2) + r_uav * sin(th);
    plot(x_circle_uav, y_circle_uav, 'Color', c_bs_range);
    hold on;
end

% Finds the radius of the coverage of the base station and plots them.
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, 'Color', c_bs_range);
hold on;

% Getting the labels for the UAV
numbered_labelling_uav = (2:41)';
numbered_labelling_uav = num2str(numbered_labelling_uav);
numbered_labelling_bs = '1';
dx = 0.8; dy = 0.8; % Displacement so the text does not overlay the data points

% Plotting the user data, the UAV data and the base Station Data
users = scatter(X, Y, [], c_data, '.');
hold on;
p_centroid = plot(centroids(:,1), centroids(:,2), 'kx', 'MarkerSize', 10, ...
    'LineWidth', 3, 'DisplayName', 'Centroids'); 
hold on;
p_uav_1 = scatter(uav_1_updated(:,1), uav_1_updated(:,2), 70, c_uav_1, '^', 'filled');
hold on;
p_uav_2 = scatter(uav_2_updated(:,1), uav_2_updated(:,2), 40, c_uav_2, '^', 'filled');
hold on;
p_center = plot(x_bs, y_bs, 'ks', 'MarkerSize', 10, 'LineWidth', 3);
hold off;
axis equal;

legend([p_centroid, p_uav_1, p_uav_2, p_center], 'Centroids', ... 
    'UAV Intersection 1', 'UAV Intersection 2', 'Base Station');
title('Communication Ranges');
xlabel('X Distance');
ylabel('Y Distance');
text(centroids(:,1) + dx, centroids(:,2) + dy, numbered_labelling_uav);
text(x_bs + dx, y_bs + dy, numbered_labelling_bs);


%% Plotting the updated optimal UAV Placement Locations

figure('Name', 'Updated Optimal UAV Placement', 'units','normalized',...
    'outerposition', [0 0 1 1]);

% Finds the radius of the coverage of the base station and plots them.
th = 0:pi/50:2*pi;
x_circle = x_bs + r_bs * cos(th);
y_circle = y_bs + r_bs * sin(th);
plot(x_circle, y_circle, 'Color', c_bs_range);
hold on;

% Plotting the user data, the UAV data and the base Station Data
users = scatter(X, Y, [], c_data, '.');
hold on;
p_centroid = plot(centroids(:,1), centroids(:,2), 'kx', 'MarkerSize', 10, ...
    'LineWidth', 3, 'DisplayName', 'Centroids'); 
hold on;
p_uav_1 = scatter(uav_1_updated(:,1), uav_1_updated(:,2), 70, c_uav_1, '^', 'filled');
hold on;
p_uav_2 = scatter(uav_2_updated(:,1), uav_2_updated(:,2), 40, c_uav_2, '^', 'filled');
hold on;
p_center = plot(x_bs, y_bs, 'ks', 'MarkerSize', 10, 'LineWidth', 3);
hold off;
axis equal;

legend([p_centroid, p_uav_1, p_uav_2, p_center, users], 'Centroids', ... 
    'UAV Intersection 1', 'UAV Intersection 2', 'Base Station', 'Users');
title('Updated Optimal UAV Placement');
xlabel('X Distance');
ylabel('Y Distance');
text(centroids(:,1) + dx, centroids(:,2) + dy, numbered_labelling_uav);
text(x_bs + dx, y_bs + dy, numbered_labelling_bs);

%% Calculating the Performance Metrics for the Dijkstra Algorithm

dist_matrix_orig = (uav_1 - uav_2)' * (uav_1 - uav_2);
dist_matrix_updated = (uav_1_updated - uav_2_updated)' * ... 
    (uav_1_updated - uav_2_updated);

latency_reduced_per = (dist_matrix_orig(1, 1) + dist_matrix_orig(2, 2) - ...
    dist_matrix_updated(1,1) - dist_matrix_updated(2, 2)) / ...
    (dist_matrix_orig(1, 1) + dist_matrix_orig(2, 2)) * 100;

additional_energy_saved = (dist_matrix_orig(1, 1) + dist_matrix_orig(2, 2) - ...
    dist_matrix_updated(1,1) - dist_matrix_updated(2, 2)) * w_mot;

fprintf('\n');
fprintf('Percentage Latency Reduced: %f \n', latency_reduced_per);
fprintf('Additional Energy Saved: %f \n', additional_energy_saved);
##### SOURCE END #####
--></body></html>